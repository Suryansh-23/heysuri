---
import FullscreenFrame from "@/components/FullscreenFrame.astro";

const {
  id = "",
  title = "Search visualizer",
  description = "",
  algorithms,
  defaultAlgorithm,
  presets,
  defaultPreset,
  compareAlgorithms,
  defaults,
  features,
} = Astro.props;

const resolvedAlgorithms =
  Array.isArray(algorithms) && algorithms.length > 0
    ? algorithms
    : ["binary", "interpolation"];

const resolvedPresets =
  Array.isArray(presets) && presets.length > 0
    ? presets
    : ["uniform", "piecewise", "skewed", "duplicates"];

const resolvedFeatures = {
  showAlgorithmSelect: true,
  showDatasetControls: true,
  showTargetControl: true,
  showPlaybackControls: true,
  showSpeedControl: true,
  showDuplicateControls: true,
  showSipControls: false,
  showWhyFails: false,
  showCompare: false,
  showMetrics: true,
  ...features,
};

const resolvedDefaults = {
  n: 12000,
  noise: 0.25,
  duplicateProbability: 0.08,
  duplicateLength: 16,
  targetPercent: 52,
  speed: 420,
  slopeInterval: 4,
  ...defaults,
};

const config = {
  id,
  title,
  description,
  algorithms: resolvedAlgorithms,
  defaultAlgorithm: defaultAlgorithm ?? resolvedAlgorithms[0],
  presets: resolvedPresets,
  defaultPreset: defaultPreset ?? resolvedPresets[0],
  compareAlgorithms:
    Array.isArray(compareAlgorithms) && compareAlgorithms.length > 0
      ? compareAlgorithms
      : ["binary", "interpolation", "interpolated-binary"],
  features: resolvedFeatures,
  defaults: resolvedDefaults,
};

const configJson = JSON.stringify(config);
---

<FullscreenFrame class="search-visualizer-frame not-prose">
  <section
    class="search-visualizer"
    data-search-visualizer
    data-config={configJson}
    data-visualizer-id={id}
  >
    <div class="search-visualizer__topbar">
      <div class="search-visualizer__branding">
        <p class="search-visualizer__eyebrow">Mini visualizer</p>
        <div class="search-visualizer__title-block">
          <h3 class="search-visualizer__title">{title}</h3>
          {description && (
            <p class="search-visualizer__description">{description}</p>
          )}
        </div>
      </div>
      <div class="search-visualizer__top-actions">
        {resolvedFeatures.showMetrics && (
          <dl class="search-visualizer__metrics">
            <div>
              <dt>Reads</dt>
              <dd data-metric="reads">0</dd>
            </div>
            <div>
              <dt>Iteration</dt>
              <dd data-metric="iteration">0</dd>
            </div>
            <div>
              <dt>Interval</dt>
              <dd data-metric="interval">-</dd>
            </div>
          </dl>
        )}
        <div class="search-visualizer__window-actions">
          <button
            type="button"
            class="search-visualizer__window-button"
            data-fullscreen-toggle
            aria-label="Expand visualizer"
          >
            Expand
          </button>
          <button
            type="button"
            class="search-visualizer__window-button"
            data-fullscreen-close
            aria-label="Close full screen"
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <div class="search-visualizer__layout">
      <aside class="search-visualizer__rail">
        {resolvedFeatures.showPlaybackControls && (
          <div class="search-visualizer__rail-block">
            <p class="search-visualizer__rail-title">Playback</p>
            <div class="search-visualizer__actions">
              <button type="button" data-control="step">Step</button>
              <button type="button" data-control="play">Play</button>
              <button type="button" data-control="reset">Reset</button>
            </div>
            {resolvedFeatures.showSpeedControl && (
              <label class="search-visualizer__control search-visualizer__control--wide">
                <span>
                  Speed <strong data-control-value="speed"></strong>
                </span>
                <input
                  type="range"
                  min="120"
                  max="1200"
                  step="40"
                  data-control="speed"
                />
              </label>
            )}
          </div>
        )}

        <div class="search-visualizer__rail-block">
          <p class="search-visualizer__rail-title">Controls</p>
          <div class="search-visualizer__controls">
            {resolvedFeatures.showAlgorithmSelect && (
              <label class="search-visualizer__control">
                <span>Algorithm</span>
                <select data-control="algorithm"></select>
              </label>
            )}
            {resolvedFeatures.showDatasetControls && (
              <label class="search-visualizer__control">
                <span>Distribution preset</span>
                <select data-control="preset"></select>
              </label>
            )}
            {resolvedFeatures.showDatasetControls && (
              <label class="search-visualizer__control search-visualizer__control--wide">
                <span>
                  Array size <strong data-control-value="n"></strong>
                </span>
                <input
                  type="range"
                  min="1000"
                  max="50000"
                  step="500"
                  data-control="n"
                />
              </label>
            )}
            {resolvedFeatures.showDatasetControls && (
              <label class="search-visualizer__control search-visualizer__control--wide">
                <span>
                  Noise <strong data-control-value="noise"></strong>
                </span>
                <input
                  type="range"
                  min="0"
                  max="0.9"
                  step="0.05"
                  data-control="noise"
                />
              </label>
            )}
            {resolvedFeatures.showDatasetControls &&
              resolvedFeatures.showDuplicateControls && (
                <label class="search-visualizer__control search-visualizer__control--wide">
                  <span>
                    Duplicates <strong data-control-value="dup"></strong>
                  </span>
                  <input
                    type="range"
                    min="0"
                    max="0.4"
                    step="0.02"
                    data-control="duplicate-prob"
                  />
                </label>
              )}
            {resolvedFeatures.showDatasetControls &&
              resolvedFeatures.showDuplicateControls && (
                <label class="search-visualizer__control search-visualizer__control--wide">
                  <span>
                    Plateau length <strong data-control-value="dup-len"></strong>
                  </span>
                  <input
                    type="range"
                    min="4"
                    max="40"
                    step="2"
                    data-control="duplicate-len"
                  />
                </label>
              )}
            {resolvedFeatures.showSipControls && (
              <label class="search-visualizer__control search-visualizer__control--wide">
                <span>
                  SIP slope refresh (k)
                  <strong data-control-value="slope"></strong>
                </span>
                <input
                  type="range"
                  min="1"
                  max="10"
                  step="1"
                  data-control="slope-interval"
                />
              </label>
            )}
            {resolvedFeatures.showTargetControl && (
              <label class="search-visualizer__control search-visualizer__control--wide">
                <span>
                  Target <strong data-control-value="target"></strong>
                </span>
                <input
                  type="range"
                  min="0"
                  max="100"
                  step="1"
                  data-control="target"
                />
              </label>
            )}
          </div>
        </div>

        <div class="search-visualizer__rail-block">
          <p class="search-visualizer__rail-title">Readout</p>
          <div class="search-visualizer__stats" data-stats>
            <div>
              <span>Probe</span>
              <strong data-stat="probe">-</strong>
            </div>
            <div>
              <span>L / R</span>
              <strong data-stat="lr">-</strong>
            </div>
            <div>
              <span>V[L] / V[R]</span>
              <strong data-stat="values">-</strong>
            </div>
            <div>
              <span>Formula</span>
              <strong data-stat="formula">-</strong>
            </div>
          </div>
        </div>

        {resolvedFeatures.showWhyFails && (
          <div class="search-visualizer__rail-block search-visualizer__why" data-why>
            <p class="search-visualizer__rail-title">Why this fails</p>
            <ul data-why-list></ul>
          </div>
        )}

        {resolvedFeatures.showCompare && (
          <div
            class="search-visualizer__rail-block search-visualizer__compare"
            data-compare
          >
            <p class="search-visualizer__rail-title">Compare modes</p>
            <div class="search-visualizer__compare-list" data-compare-list></div>
          </div>
        )}
      </aside>

      <div class="search-visualizer__plot-area">
        <div class="search-visualizer__plot">
          <div class="search-visualizer__plot-meta">
            <span data-target-label>Target: --</span>
            <span data-status-label>--</span>
          </div>
          <canvas data-visualizer-canvas></canvas>
          <div class="search-visualizer__plot-axis">
            <span>Block number -&gt;</span>
            <span>Timestamp ^</span>
          </div>
        </div>
      </div>
    </div>
  </section>
</FullscreenFrame>

<style>
  :global(.search-visualizer-frame) {
    position: relative;
  }

  :global(.search-visualizer-frame:not(.is-fullscreen)) {
    width: min(94vw, 1040px);
    margin-left: 50%;
    transform: translateX(-50%);
  }

  :global(.search-visualizer-frame.is-fullscreen) {
    width: 100%;
    margin: 0;
    transform: none;
  }

  .search-visualizer {
    --sv-bg: var(--color-surface);
    --sv-border: var(--color-border);
    --sv-ink: var(--color-ink);
    --sv-muted: var(--color-muted-text);
    --sv-accent: var(--color-accent);
    --sv-accent-muted: var(--color-accent-muted);
    --sv-plot-height: clamp(200px, 28vw, 280px);

    border: 1px solid var(--sv-border);
    background: var(--sv-bg);
    display: grid;
  }

  :global(.dark) .search-visualizer {
    --sv-bg: var(--color-dark-surface);
    --sv-border: var(--color-dark-border);
    --sv-ink: var(--color-dark-ink);
    --sv-muted: var(--color-dark-muted-text);
    --sv-accent: var(--color-dark-accent);
    --sv-accent-muted: var(--color-dark-accent-muted);
  }

  :global(.search-visualizer-frame.is-fullscreen) .search-visualizer {
    --sv-plot-height: clamp(280px, 55vh, 460px);
  }

  .search-visualizer__topbar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.8rem;
    align-items: center;
    justify-content: space-between;
    padding: 0.55rem 0.7rem;
    border-bottom: 1px solid var(--sv-border);
    background: var(--color-bg);
  }

  :global(.dark) .search-visualizer__topbar {
    background: var(--color-dark-bg);
  }

  .search-visualizer__branding {
    display: flex;
    gap: 0.7rem;
    align-items: center;
    min-width: 0;
  }

  .search-visualizer__title-block {
    display: grid;
    gap: 0.2rem;
    min-width: 0;
  }

  .search-visualizer__eyebrow {
    margin: 0;
    font-family: var(--font-sans);
    font-size: 0.6rem;
    letter-spacing: 0.28em;
    text-transform: uppercase;
    color: var(--sv-muted);
  }

  .search-visualizer__title {
    margin: 0;
    font-size: 1.05rem;
    line-height: 1.3;
    color: var(--sv-ink);
  }

  .search-visualizer__description {
    margin: 0;
    color: var(--sv-muted);
    font-size: 0.82rem;
    line-height: 1.5;
  }

  .search-visualizer__top-actions {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.75rem;
    margin-left: auto;
  }

  .search-visualizer__metrics {
    display: flex;
    flex-wrap: wrap;
    gap: 0.7rem;
    align-items: center;
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: var(--sv-muted);
    margin: 0;
  }

  .search-visualizer__metrics div {
    display: grid;
    gap: 0.15rem;
    padding-left: 0.65rem;
    border-left: 1px solid var(--sv-border);
  }

  .search-visualizer__metrics div:first-child {
    border-left: none;
    padding-left: 0;
  }

  .search-visualizer__metrics dd {
    margin: 0;
    font-size: 0.68rem;
    letter-spacing: 0.08em;
    color: var(--sv-ink);
  }

  .search-visualizer__window-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
  }

  .search-visualizer__window-button {
    border: 1px solid var(--sv-border);
    background: var(--color-bg);
    color: var(--sv-ink);
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    padding: 0.3rem 0.45rem;
    cursor: pointer;
  }

  :global(.dark) .search-visualizer__window-button {
    background: var(--color-dark-bg);
  }

  .search-visualizer__window-button:hover {
    border-color: var(--sv-muted);
    transform: translateY(-1px);
  }

  .search-visualizer__window-button[data-fullscreen-close] {
    display: none;
  }

  :global(.search-visualizer-frame.is-fullscreen)
    .search-visualizer__window-button[data-fullscreen-close] {
    display: inline-flex;
  }

  :global(.search-visualizer-frame.is-fullscreen)
    .search-visualizer__window-button[data-fullscreen-toggle] {
    display: none;
  }

  .search-visualizer__layout {
    display: grid;
    grid-template-columns: minmax(220px, 320px) minmax(0, 1fr);
    min-height: 0;
  }

  .search-visualizer__rail {
    border-right: 1px solid var(--sv-border);
    background: var(--color-bg);
    padding: 0.65rem;
    display: grid;
    gap: 0.7rem;
    align-content: start;
    overflow: auto;
    align-self: stretch;
    min-height: 0;
  }

  :global(.dark) .search-visualizer__rail {
    background: var(--color-dark-bg);
  }

  .search-visualizer__rail-block {
    display: grid;
    gap: 0.5rem;
    padding-top: 0.6rem;
    border-top: 1px solid var(--sv-border);
  }

  .search-visualizer__rail-block:first-child {
    padding-top: 0;
    border-top: none;
  }

  .search-visualizer__rail-title {
    margin: 0;
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.22em;
    text-transform: uppercase;
    color: var(--sv-muted);
  }

  .search-visualizer__controls {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 0.45rem 0.6rem;
    align-items: end;
  }

  .search-visualizer__control {
    display: grid;
    gap: 0.3rem;
    font-family: var(--font-sans);
    font-size: 0.58rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: var(--sv-muted);
    min-width: 0;
  }

  .search-visualizer__control--wide {
    grid-column: 1 / -1;
  }

  .search-visualizer__control strong {
    color: var(--sv-ink);
    font-weight: 600;
    margin-left: 0.35rem;
  }

  .search-visualizer__control input,
  .search-visualizer__control select {
    border: 1px solid var(--sv-border);
    background: var(--color-bg);
    color: var(--sv-ink);
    padding: 0.25rem 0.4rem;
    font-family: var(--font-sans);
    font-size: 0.68rem;
  }

  :global(.dark) .search-visualizer__control input,
  :global(.dark) .search-visualizer__control select {
    background: var(--color-dark-bg);
  }

  .search-visualizer__control input[type="range"] {
    padding: 0;
    width: 100%;
    accent-color: var(--sv-accent);
  }

  .search-visualizer__actions {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 0.35rem;
  }

  .search-visualizer__actions button {
    border: 1px solid var(--sv-border);
    background: var(--color-bg);
    color: var(--sv-ink);
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    padding: 0.3rem 0.35rem;
    cursor: pointer;
  }

  :global(.dark) .search-visualizer__actions button {
    background: var(--color-dark-bg);
  }

  .search-visualizer__actions button:hover {
    border-color: var(--sv-muted);
    transform: translateY(-1px);
  }

  .search-visualizer__stats {
    display: grid;
    gap: 0.35rem;
    font-family: var(--font-sans);
    font-size: 0.58rem;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    color: var(--sv-muted);
  }

  .search-visualizer__stats strong {
    display: block;
    color: var(--sv-ink);
    font-size: 0.7rem;
    letter-spacing: 0.06em;
    text-transform: none;
    font-family: var(--font-serif);
  }

  .search-visualizer__why ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: 0.3rem;
    font-size: 0.8rem;
    color: var(--sv-ink);
  }

  .search-visualizer__compare-list {
    display: grid;
    gap: 0.5rem;
  }

  .search-visualizer__compare-row {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 0.5rem;
    align-items: center;
    font-family: var(--font-sans);
    font-size: 0.58rem;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    color: var(--sv-muted);
  }

  .search-visualizer__compare-bar {
    height: 0.4rem;
    border: 1px solid var(--sv-border);
    background: var(--color-surface);
    position: relative;
  }

  :global(.dark) .search-visualizer__compare-bar {
    background: var(--color-dark-surface);
  }

  .search-visualizer__compare-fill {
    position: absolute;
    inset: 0;
    width: var(--bar-size, 0%);
    background: var(--sv-accent);
  }

  .search-visualizer__plot-area {
    padding: clamp(0.6rem, 1.3vw, 0.85rem);
    background: var(--sv-bg);
    min-width: 0;
    display: grid;
  }

  .search-visualizer__plot {
    border: 1px solid var(--sv-border);
    background: var(--color-bg);
    padding: 0.55rem;
    display: grid;
    gap: 0.55rem;
  }

  :global(.dark) .search-visualizer__plot {
    background: var(--color-dark-bg);
  }

  .search-visualizer__plot-meta {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 0.4rem;
    font-family: var(--font-sans);
    font-size: 0.55rem;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: var(--sv-muted);
  }

  .search-visualizer__plot canvas {
    width: 100%;
    height: var(--sv-plot-height);
    border: 1px solid var(--sv-border);
    background: var(--color-surface);
    cursor: crosshair;
  }

  :global(.dark) .search-visualizer__plot canvas {
    background: var(--color-dark-surface);
  }

  .search-visualizer__plot-axis {
    display: flex;
    justify-content: space-between;
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: var(--sv-muted);
  }

  @media (max-width: 1000px) {
    .search-visualizer__controls {
      grid-template-columns: 1fr;
    }
  }

  @media (max-width: 900px) {
    :global(.search-visualizer-frame:not(.is-fullscreen)) {
      width: 100%;
      margin-left: 0;
      transform: none;
    }

    .search-visualizer__layout {
      grid-template-columns: 1fr;
    }

    .search-visualizer__rail {
      border-right: none;
      border-top: 1px solid var(--sv-border);
      max-height: none;
    }

    .search-visualizer__top-actions {
      width: 100%;
      justify-content: space-between;
    }

    .search-visualizer__metrics {
      width: 100%;
      justify-content: flex-start;
    }
  }
</style>

<script>
  type Algorithm =
    | "binary"
    | "interpolation"
    | "sip"
    | "tip"
    | "interpolated-binary";

  type Preset = "uniform" | "piecewise" | "skewed" | "duplicates" | "chaos";

  type Dataset = {
    values: number[];
    min: number;
    max: number;
    hasDuplicates: boolean;
    duplicateRanges: Array<[number, number]>;
  };

  type VisualizerState = {
    algorithm: Algorithm;
    L: number;
    R: number;
    M: number | null;
    tL: number;
    tR: number;
    tM: number | null;
    probe: number | null;
    tP: number;
    iteration: number;
    reads: number;
    targetValue: number;
    slope: number | null;
    slopeCounter: number;
    issues: string[];
    history: number[];
    intervalHistory: number[];
    done: boolean;
  };

  type ControlDefaults = {
    n: number;
    noise: number;
    duplicateProbability: number;
    duplicateLength: number;
    targetPercent: number;
    speed: number;
    slopeInterval: number;
  };

  type VisualizerConfig = {
    algorithms?: Algorithm[];
    presets?: Preset[];
    compareAlgorithms?: Algorithm[];
    features?: Record<string, boolean>;
    defaults?: Partial<ControlDefaults>;
    defaultAlgorithm?: Algorithm;
    defaultPreset?: Preset;
  };

  type DatasetSettings = {
    n: number;
    noise: number;
    duplicateProbability: number;
    duplicateLength: number;
    preset: Preset;
  };

  const ALGORITHM_LABELS: Record<Algorithm, string> = {
    binary: "Binary",
    interpolation: "Interpolation",
    sip: "SIP (slope reuse)",
    tip: "TIP (three point)",
    "interpolated-binary": "Interpolated binary",
  };

  const PRESET_LABELS: Record<Preset, string> = {
    uniform: "Uniform-ish",
    piecewise: "Piecewise linear",
    skewed: "Skewed/exponential",
    duplicates: "Duplicate segments",
    chaos: "Distribution chaos",
  };

  const clamp = (value: number, min: number, max: number): number =>
    Math.min(Math.max(value, min), max);

  const formatNumber = (value: number): string =>
    new Intl.NumberFormat("en-US", {
      notation: "compact",
      maximumFractionDigits: 1,
    }).format(value);

  function initSearchVisualizers() {
    document
      .querySelectorAll("[data-search-visualizer]")
      .forEach((root) => {
        if (!(root instanceof HTMLElement)) return;
        if (root.dataset.visualizerInitialized === "true") return;
        root.dataset.visualizerInitialized = "true";

        const config: VisualizerConfig = root.dataset.config
          ? JSON.parse(root.dataset.config)
          : {};

        const features: Record<string, boolean> = config.features ?? {};
        const defaults: Partial<ControlDefaults> = config.defaults ?? {};

        const canvas = root.querySelector<HTMLCanvasElement>(
          "[data-visualizer-canvas]",
        );
        const algorithmSelect = root.querySelector<HTMLSelectElement>(
          "[data-control=algorithm]",
        );
        const presetSelect = root.querySelector<HTMLSelectElement>(
          "[data-control=preset]",
        );
        const nControl = root.querySelector<HTMLInputElement>("[data-control=n]");
        const noiseControl =
          root.querySelector<HTMLInputElement>("[data-control=noise]");
        const dupControl = root.querySelector<HTMLInputElement>(
          "[data-control=duplicate-prob]",
        );
        const dupLenControl = root.querySelector<HTMLInputElement>(
          "[data-control=duplicate-len]",
        );
        const targetControl =
          root.querySelector<HTMLInputElement>("[data-control=target]");
        const speedControl =
          root.querySelector<HTMLInputElement>("[data-control=speed]");
        const slopeControl =
          root.querySelector<HTMLInputElement>("[data-control=slope-interval]");
        const stepButton =
          root.querySelector<HTMLButtonElement>("[data-control=step]");
        const playButton =
          root.querySelector<HTMLButtonElement>("[data-control=play]");
        const resetButton =
          root.querySelector<HTMLButtonElement>("[data-control=reset]");
        const targetLabel = root.querySelector("[data-target-label]");
        const statusLabel = root.querySelector("[data-status-label]");
        const statProbe = root.querySelector("[data-stat=probe]");
        const statLR = root.querySelector("[data-stat=lr]");
        const statValues = root.querySelector("[data-stat=values]");
        const statFormula = root.querySelector("[data-stat=formula]");
        const metricReads = root.querySelector("[data-metric=reads]");
        const metricIteration = root.querySelector("[data-metric=iteration]");
        const metricInterval = root.querySelector("[data-metric=interval]");
        const whyList = root.querySelector("[data-why-list]");
        const compareList = root.querySelector("[data-compare-list]");

        if (!(canvas instanceof HTMLCanvasElement)) return;

        const ctx = canvas.getContext("2d");
        if (!ctx) return;

        let dataset: Dataset | null = null;
        let state: VisualizerState | null = null;
        let playing = false;
        let playTimer: number | null = null;
        let resizeObserver: ResizeObserver | null = null;
        let lastTargetIndex: number | null = null;

        const getColors = () => {
          const rootStyles = getComputedStyle(document.documentElement);
          const isDark = document.documentElement.classList.contains("dark");
          const color = (name: string) =>
            rootStyles.getPropertyValue(name).trim();

          return {
            ink: color(isDark ? "--color-dark-ink" : "--color-ink"),
            muted: color(isDark ? "--color-dark-muted-text" : "--color-muted-text"),
            border: color(isDark ? "--color-dark-border" : "--color-border"),
            accent: color(isDark ? "--color-dark-accent" : "--color-accent"),
            accentMuted: color(
              isDark ? "--color-dark-accent-muted" : "--color-accent-muted",
            ),
            surface: color(isDark ? "--color-dark-surface" : "--color-surface"),
            bg: color(isDark ? "--color-dark-bg" : "--color-bg"),
          };
        };

        const defaultAlgorithm: Algorithm = config.defaultAlgorithm ?? "binary";
        const defaultPreset: Preset = config.defaultPreset ?? "uniform";

        const controlValues: ControlDefaults & {
          algorithm: Algorithm;
          preset: Preset;
        } = {
          algorithm: defaultAlgorithm,
          preset: defaultPreset,
          n: defaults.n ?? 12000,
          noise: defaults.noise ?? 0.25,
          duplicateProbability: defaults.duplicateProbability ?? 0.08,
          duplicateLength: defaults.duplicateLength ?? 16,
          targetPercent: defaults.targetPercent ?? 52,
          speed: defaults.speed ?? 420,
          slopeInterval: defaults.slopeInterval ?? 4,
        };
        let datasetSettings: DatasetSettings = {
          n: controlValues.n,
          noise: controlValues.noise,
          duplicateProbability: controlValues.duplicateProbability,
          duplicateLength: controlValues.duplicateLength,
          preset: controlValues.preset,
        };

        const setControlValue = (
          control: HTMLInputElement | null,
          value: number,
        ): void => {
          if (!(control instanceof HTMLInputElement)) return;
          control.value = String(value);
        };

        const setSelectValue = (
          control: HTMLSelectElement | null,
          value: string,
        ): void => {
          if (!(control instanceof HTMLSelectElement)) return;
          control.value = value;
        };

        const updateControlLabel = (name: string, value: number): void => {
          const node = root.querySelector(
            `[data-control-value=${name}]`,
          );
          if (!node) return;
          if (name === "n") {
            node.textContent = formatNumber(Number(value));
            return;
          }
          if (name === "noise") {
            node.textContent = Number(value).toFixed(2);
            return;
          }
          if (name === "dup") {
            node.textContent = Number(value).toFixed(2);
            return;
          }
          if (name === "dup-len") {
            node.textContent = `${value}`;
            return;
          }
          if (name === "target") {
            node.textContent = `${value}%`;
            return;
          }
          if (name === "speed") {
            node.textContent = `${value}ms`;
            return;
          }
          if (name === "slope") {
            node.textContent = `${value}`;
          }
        };

        const buildSelect = (
          control: HTMLSelectElement | null,
          options: string[],
          labels: Record<string, string>,
        ): void => {
          if (!(control instanceof HTMLSelectElement)) return;
          control.innerHTML = "";
          options.forEach((option) => {
            const item = document.createElement("option");
            item.value = option;
            item.textContent = labels[option] ?? option;
            control.appendChild(item);
          });
        };

        const syncControls = () => {
          buildSelect(algorithmSelect, config.algorithms || [], ALGORITHM_LABELS);
          buildSelect(presetSelect, config.presets || [], PRESET_LABELS);

          setSelectValue(algorithmSelect, controlValues.algorithm);
          setSelectValue(presetSelect, controlValues.preset);
          setControlValue(nControl, controlValues.n);
          setControlValue(noiseControl, controlValues.noise);
          setControlValue(dupControl, controlValues.duplicateProbability);
          setControlValue(dupLenControl, controlValues.duplicateLength);
          setControlValue(targetControl, controlValues.targetPercent);
          setControlValue(speedControl, controlValues.speed);
          setControlValue(slopeControl, controlValues.slopeInterval);

          updateControlLabel("n", controlValues.n);
          updateControlLabel("noise", controlValues.noise);
          updateControlLabel("dup", controlValues.duplicateProbability);
          updateControlLabel("dup-len", controlValues.duplicateLength);
          updateControlLabel("target", controlValues.targetPercent);
          updateControlLabel("speed", controlValues.speed);
          updateControlLabel("slope", controlValues.slopeInterval);
        };

        const generateDataset = (): Dataset => {
          const size = Math.max(1000, Number(controlValues.n));
          const noise = Number(controlValues.noise);
          const duplicateProbability = Number(controlValues.duplicateProbability);
          const duplicateLength = Math.max(2, Number(controlValues.duplicateLength));
          const preset = controlValues.preset;

          const values = new Array(size);
          const baseTimestamp = 1_700_000_000;
          const baseStep = 12;
          let time = baseTimestamp;
          let duplicateRun = 0;
          let hasDuplicates = false;
          let duplicateRanges: Array<[number, number]> = [];
          let currentDupStart: number | null = null;

          const forcedDuplicateStart = Math.floor(size * 0.58);
          const forcedDuplicateLength = Math.floor(
            Math.min(size * 0.1, duplicateLength * 2),
          );

          for (let i = 0; i < size; i += 1) {
            let step = baseStep;

            if (preset === "piecewise" || preset === "chaos") {
              if (i < size * 0.35) step = 11;
              else if (i < size * 0.6) step = 9;
              else step = 14;
            }

            if (preset === "skewed") {
              const factor = Math.pow(i / size, 2);
              step = baseStep * (0.9 + factor * 1.6);
            }

            if (preset === "chaos") {
              if (i > size * 0.45 && i < size * 0.52) step = 18;
              if (i > size * 0.7) step = 7;
              step *= 0.8 + Math.random() * 0.8;
            }

            if (duplicateRun > 0) {
              step = 0;
              duplicateRun -= 1;
              hasDuplicates = true;
            } else if (
              (preset === "duplicates" || preset === "chaos") &&
              i === forcedDuplicateStart
            ) {
              duplicateRun = forcedDuplicateLength;
              step = 0;
              currentDupStart = i;
              hasDuplicates = true;
            } else if (Math.random() < duplicateProbability) {
              duplicateRun = Math.max(2, Math.floor(duplicateLength * 0.8));
              step = 0;
              currentDupStart = i;
              hasDuplicates = true;
            }

            if (step > 0 && noise > 0) {
              const jitter = step * noise * (Math.random() * 2 - 1);
              step = Math.max(1, step + jitter);
            }

            time += step;
            values[i] = Math.round(time);

            if (step !== 0 && currentDupStart !== null) {
              duplicateRanges.push([currentDupStart, i]);
              currentDupStart = null;
            }
          }

          if (currentDupStart !== null) {
            duplicateRanges.push([currentDupStart, size - 1]);
          }

          return {
            values,
            min: values[0],
            max: values[values.length - 1],
            hasDuplicates,
            duplicateRanges,
          };
        };

        const findIndexByValue = (values: number[], target: number): number => {
          let left = 0;
          let right = values.length - 1;
          while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (values[mid] < target) {
              left = mid + 1;
            } else {
              right = mid;
            }
          }
          return left;
        };

        const getTargetIndex = (): number => {
          if (!dataset) return 0;
          const percent = clamp(controlValues.targetPercent, 0, 100) / 100;
          return Math.floor(percent * (dataset.values.length - 1));
        };

        const readValue = (
          stateRef: VisualizerState,
          index: number,
        ): number => {
          if (!dataset) return 0;
          stateRef.reads += 1;
          return dataset.values[clamp(index, 0, dataset.values.length - 1)];
        };

        const computeSlope = (stateRef: VisualizerState): number | null => {
          const denom = stateRef.tR - stateRef.tL;
          if (denom === 0) return null;
          return (stateRef.R - stateRef.L) / denom;
        };

        const threePointEstimate = (
          target: number,
          points: Array<{ x: number; y: number }>,
        ): number | null => {
          const [p1, p2, p3] = points;
          const denom1 = (p1.y - p2.y) * (p1.y - p3.y);
          const denom2 = (p2.y - p1.y) * (p2.y - p3.y);
          const denom3 = (p3.y - p1.y) * (p3.y - p2.y);

          if (denom1 === 0 || denom2 === 0 || denom3 === 0) {
            return null;
          }

          const term1 =
            p1.x * ((target - p2.y) * (target - p3.y)) / denom1;
          const term2 =
            p2.x * ((target - p1.y) * (target - p3.y)) / denom2;
          const term3 =
            p3.x * ((target - p1.y) * (target - p2.y)) / denom3;

          return term1 + term2 + term3;
        };

        const initState = (): VisualizerState | null => {
          if (!dataset) return null;
          const targetIndex = getTargetIndex();
          lastTargetIndex = targetIndex;
          const targetValue = dataset.values[targetIndex];
          const stateRef: VisualizerState = {
            algorithm: controlValues.algorithm,
            L: 0,
            R: dataset.values.length - 1,
            M: null,
            tL: 0,
            tR: 0,
            tM: null,
            probe: null,
            tP: 0,
            iteration: 0,
            reads: 0,
            targetValue,
            slope: null,
            slopeCounter: 0,
            issues: [],
            history: [],
            intervalHistory: [],
            done: false,
          };

          stateRef.tL = readValue(stateRef, stateRef.L);
          stateRef.tR = readValue(stateRef, stateRef.R);

          if (stateRef.algorithm === "tip") {
            stateRef.M = Math.floor((stateRef.L + stateRef.R) / 2);
            stateRef.tM = readValue(stateRef, stateRef.M);
          }

          if (stateRef.algorithm === "sip") {
            stateRef.slope = computeSlope(stateRef);
          }

          return stateRef;
        };

        const computeProbe = (stateRef: VisualizerState): number => {
          const { algorithm, L, R, tL, tR, tM, targetValue } = stateRef;

          if (algorithm === "binary") {
            return Math.floor((L + R) / 2);
          }

          if (algorithm === "interpolated-binary") {
            if (tR === tL) return Math.floor((L + R) / 2);
            const estimate =
              L + Math.floor(((targetValue - tL) * (R - L)) / (tR - tL));
            return estimate;
          }

          if (algorithm === "interpolation") {
            if (tR === tL) return Math.floor((L + R) / 2);
            return L + Math.floor(((targetValue - tL) * (R - L)) / (tR - tL));
          }

          if (algorithm === "sip") {
            if (!stateRef.slope || Number.isNaN(stateRef.slope)) {
              return Math.floor((L + R) / 2);
            }
            if (stateRef.probe === null) {
              return L + Math.floor((targetValue - tL) * stateRef.slope);
            }
            return (
              stateRef.probe +
              Math.floor((targetValue - stateRef.tP) * stateRef.slope)
            );
          }

          if (algorithm === "tip") {
            const estimate = threePointEstimate(targetValue, [
              { x: L, y: tL },
              { x: stateRef.M ?? Math.floor((L + R) / 2), y: tM ?? tL },
              { x: R, y: tR },
            ]);

            if (estimate === null || Number.isNaN(estimate)) {
              return Math.floor((L + R) / 2);
            }

            return Math.floor(estimate);
          }

          return Math.floor((L + R) / 2);
        };

        const updateIssues = (stateRef: VisualizerState): void => {
          const issues = [];

          if (dataset?.hasDuplicates) {
            issues.push("Duplicate timestamps compress the value range.");
          }

          if (stateRef.history.length >= 4) {
            const slice = stateRef.history.slice(-4);
            if (slice[0] === slice[2] && slice[1] === slice[3]) {
              issues.push("Probe oscillates between two regions.");
            }
          }

          if (stateRef.intervalHistory.length >= 3) {
            const last = stateRef.intervalHistory.slice(-3);
            if (last[0] === last[1] && last[1] === last[2]) {
              issues.push("Interval stops shrinking; fallback needed.");
            }
          }

          stateRef.issues = issues;
        };

        const stepState = () => {
          if (!state || !dataset) return;
          if (state.done) return;

          state.iteration += 1;

          if (state.L > state.R) {
            state.done = true;
            return;
          }

          let probe = computeProbe(state);
          probe = clamp(probe, state.L, state.R);
          state.probe = probe;
          state.tP = readValue(state, probe);

          if (state.tP === state.targetValue) {
            state.done = true;
          }

          if (!state.done) {
            if (
              state.algorithm === "binary" ||
              state.algorithm === "interpolated-binary" ||
              state.algorithm === "interpolation" ||
              state.algorithm === "sip"
            ) {
              if (state.tP < state.targetValue) {
                state.L = probe + 1;
                if (state.L <= state.R) {
                  state.tL = readValue(state, state.L);
                }
              } else {
                state.R = probe - 1;
                if (state.L <= state.R) {
                  state.tR = readValue(state, state.R);
                }
              }
            } else if (state.algorithm === "tip") {
              if (state.tP < state.targetValue) {
                state.L = probe;
                state.tL = state.tP;
              } else {
                state.R = probe;
                state.tR = state.tP;
              }
              state.M = probe;
              state.tM = state.tP;
            }
          }

          if (state.algorithm === "sip") {
            state.slopeCounter += 1;
            const interval = Math.max(1, Number(controlValues.slopeInterval));
            if (state.slopeCounter >= interval) {
              state.slopeCounter = 0;
              if (state.L <= state.R) {
                state.tL = readValue(state, state.L);
                state.tR = readValue(state, state.R);
              }
              state.slope = computeSlope(state);
            }
          }

          state.history.push(probe);
          if (state.history.length > 10) state.history.shift();
          state.intervalHistory.push(state.R - state.L);
          if (state.intervalHistory.length > 6) state.intervalHistory.shift();

          updateIssues(state);

          if (state.iteration > 200) {
            state.done = true;
          }
        };

        const simulateAlgorithm = (
          algorithm: Algorithm,
        ): { reads: number; iterations: number } => {
          if (!dataset) return { reads: 0, iterations: 0 };
          const simState: VisualizerState = {
            algorithm,
            L: 0,
            R: dataset.values.length - 1,
            M: null,
            tL: 0,
            tR: 0,
            tM: null,
            probe: null,
            tP: 0,
            iteration: 0,
            reads: 0,
            targetValue: dataset.values[getTargetIndex()],
            slope: null,
            slopeCounter: 0,
            issues: [],
            history: [],
            intervalHistory: [],
            done: false,
          };

          simState.tL = readValue(simState, simState.L);
          simState.tR = readValue(simState, simState.R);

          if (algorithm === "tip") {
            simState.M = Math.floor((simState.L + simState.R) / 2);
            simState.tM = readValue(simState, simState.M);
          }

          if (algorithm === "sip") {
            simState.slope = computeSlope(simState);
          }

          while (simState.L <= simState.R && simState.iteration < 200) {
            simState.iteration += 1;
            let probe = computeProbe(simState);
            probe = clamp(probe, simState.L, simState.R);
            simState.probe = probe;
            simState.tP = readValue(simState, probe);

            if (simState.tP === simState.targetValue) break;

            if (
              algorithm === "binary" ||
              algorithm === "interpolated-binary" ||
              algorithm === "interpolation" ||
              algorithm === "sip"
            ) {
              if (simState.tP < simState.targetValue) {
                simState.L = probe + 1;
                if (simState.L <= simState.R) {
                  simState.tL = readValue(simState, simState.L);
                }
              } else {
                simState.R = probe - 1;
                if (simState.L <= simState.R) {
                  simState.tR = readValue(simState, simState.R);
                }
              }
            } else if (algorithm === "tip") {
              if (simState.tP < simState.targetValue) {
                simState.L = probe;
                simState.tL = simState.tP;
              } else {
                simState.R = probe;
                simState.tR = simState.tP;
              }
              simState.M = probe;
              simState.tM = simState.tP;
            }

            if (algorithm === "sip") {
              simState.slopeCounter += 1;
              const interval = Math.max(1, Number(controlValues.slopeInterval));
              if (simState.slopeCounter >= interval) {
                simState.slopeCounter = 0;
                if (simState.L <= simState.R) {
                  simState.tL = readValue(simState, simState.L);
                  simState.tR = readValue(simState, simState.R);
                }
                simState.slope = computeSlope(simState);
              }
            }
          }

          return { reads: simState.reads, iterations: simState.iteration };
        };

        const renderCompare = () => {
          if (!compareList || !features.showCompare) return;
          const algorithmsList: Algorithm[] = config.compareAlgorithms ?? [];
          const results = algorithmsList.map((algo) => ({
            algo,
            ...simulateAlgorithm(algo),
          }));

          const maxReads = Math.max(...results.map((item) => item.reads), 1);
          compareList.innerHTML = "";

          results.forEach((item) => {
            const row = document.createElement("div");
            row.className = "search-visualizer__compare-row";
            const label = document.createElement("span");
            label.textContent = ALGORITHM_LABELS[item.algo] || item.algo;

            const bar = document.createElement("div");
            bar.className = "search-visualizer__compare-bar";
            const fill = document.createElement("div");
            fill.className = "search-visualizer__compare-fill";
            fill.style.setProperty(
              "--bar-size",
              `${Math.round((item.reads / maxReads) * 100)}%`,
            );
            bar.appendChild(fill);

            const value = document.createElement("span");
            value.textContent = `${item.reads} reads`;

            row.appendChild(label);
            row.appendChild(bar);
            row.appendChild(value);
            compareList.appendChild(row);
          });
        };

        const updateStats = () => {
          if (!state || !dataset) return;
          const intervalSize = Math.max(0, state.R - state.L);
          if (metricReads) metricReads.textContent = `${state.reads}`;
          if (metricIteration) metricIteration.textContent = `${state.iteration}`;
          if (metricInterval) metricInterval.textContent = `${intervalSize}`;

          if (statProbe) {
            statProbe.textContent =
              state.probe === null ? "-" : `#${state.probe}`;
          }
          if (statLR) {
            statLR.textContent = `${state.L} / ${state.R}`;
          }
          if (statValues) {
            statValues.textContent = `${state.tL ?? "-"} / ${state.tR ?? "-"}`;
          }

          if (statFormula) {
            if (state.algorithm === "binary") {
              statFormula.textContent = "mid = (L + R) / 2";
            } else if (state.algorithm === "sip") {
              statFormula.textContent = "pos += (t* - V[pos]) * slope";
            } else if (state.algorithm === "tip") {
              statFormula.textContent = "pos = three-point estimate";
            } else if (state.algorithm === "interpolated-binary") {
              statFormula.textContent = "mid = interp(L,R)";
            } else {
              statFormula.textContent = "pos = interp(L,R)";
            }
          }

          if (targetLabel) {
            targetLabel.textContent = `Target: #${lastTargetIndex} | ${state.targetValue}`;
          }

          if (statusLabel) {
            statusLabel.textContent = state.done
              ? "Converged"
              : ALGORITHM_LABELS[state.algorithm] || state.algorithm;
          }

          if (whyList) {
            whyList.innerHTML = "";
            if (!state.issues || state.issues.length === 0) {
              const li = document.createElement("li");
              li.textContent = "No obvious failure mode yet.";
              whyList.appendChild(li);
            } else {
              state.issues.forEach((issue) => {
                const li = document.createElement("li");
                li.textContent = issue;
                whyList.appendChild(li);
              });
            }
          }
        };

        const drawPlot = (): void => {
          const activeDataset = dataset;
          const activeState = state;
          if (!activeDataset || !activeState) return;
          const colors = getColors();
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          const width = rect.width;
          const height = rect.height;
          canvas.width = Math.max(1, Math.floor(width * dpr));
          canvas.height = Math.max(1, Math.floor(height * dpr));
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.clearRect(0, 0, width, height);

          const padding = 16;
          const plotWidth = width - padding * 2;
          const plotHeight = height - padding * 2;
          const minVal = activeDataset.min;
          const maxVal = activeDataset.max;
          const range = maxVal - minVal || 1;

          const mapX = (index: number): number =>
            padding +
            (index / (activeDataset.values.length - 1)) * plotWidth;
          const mapY = (value: number): number =>
            padding + plotHeight - ((value - minVal) / range) * plotHeight;

          ctx.strokeStyle = colors.border;
          ctx.lineWidth = 1;
          ctx.strokeRect(padding, padding, plotWidth, plotHeight);

          ctx.strokeStyle = colors.accentMuted;
          ctx.lineWidth = 1;
          ctx.setLineDash([]);

          const step = Math.max(
            1,
            Math.floor(activeDataset.values.length / 500),
          );
          ctx.beginPath();
          for (let i = 0; i < activeDataset.values.length; i += step) {
            const x = mapX(i);
            const y = mapY(activeDataset.values[i]);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();

          ctx.setLineDash([4, 4]);
          ctx.strokeStyle = colors.border;
          const targetY = mapY(activeState.targetValue);
          ctx.beginPath();
          ctx.moveTo(padding, targetY);
          ctx.lineTo(padding + plotWidth, targetY);
          ctx.stroke();
          ctx.setLineDash([]);

          if (
            activeState.algorithm === "interpolation" ||
            activeState.algorithm === "sip" ||
            activeState.algorithm === "interpolated-binary"
          ) {
            ctx.strokeStyle = colors.accent;
            ctx.beginPath();
            ctx.moveTo(mapX(activeState.L), mapY(activeState.tL));
            ctx.lineTo(mapX(activeState.R), mapY(activeState.tR));
            ctx.stroke();
          }

          if (activeState.algorithm === "tip") {
            ctx.strokeStyle = colors.accent;
            ctx.beginPath();
            ctx.moveTo(mapX(activeState.L), mapY(activeState.tL));
            const midX = mapX(activeState.M ?? activeState.L);
            const midY = mapY(activeState.tM ?? activeState.tL);
            ctx.quadraticCurveTo(
              midX,
              midY,
              mapX(activeState.R),
              mapY(activeState.tR),
            );
            ctx.stroke();
          }

          const drawPoint = (
            index: number,
            value: number,
            color: string,
          ): void => {
            ctx.fillStyle = color;
            ctx.fillRect(mapX(index) - 3, mapY(value) - 3, 6, 6);
          };

          drawPoint(activeState.L, activeState.tL, colors.accentMuted);
          drawPoint(activeState.R, activeState.tR, colors.accentMuted);

          if (activeState.probe !== null) {
            drawPoint(activeState.probe, activeState.tP, colors.accent);
          }
        };

        const stopPlayback = () => {
          if (playTimer) {
            window.clearInterval(playTimer);
            playTimer = null;
          }
          playing = false;
          if (playButton) playButton.textContent = "Play";
        };

        const startPlayback = () => {
          if (playing) return;
          playing = true;
          if (playButton) playButton.textContent = "Pause";
          playTimer = window.setInterval(() => {
            stepState();
            drawPlot();
            updateStats();
            renderCompare();
            if (state?.done) stopPlayback();
          }, Number(controlValues.speed));
        };

        const resetState = (regenerateDataset = false): void => {
          if (regenerateDataset || !dataset) {
            dataset = generateDataset();
          }
          state = initState();
          drawPlot();
          updateStats();
          renderCompare();
        };

        const updateTargetFromPlot = (event: MouseEvent): void => {
          if (!(event instanceof MouseEvent) || !dataset) return;
          const rect = canvas.getBoundingClientRect();
          const y = clamp(event.clientY - rect.top, 0, rect.height);
          const percent = 1 - y / rect.height;
          const targetValue = dataset.min + percent * (dataset.max - dataset.min);
          const targetIndex = findIndexByValue(dataset.values, targetValue);
          controlValues.targetPercent = Math.round(
            (targetIndex / (dataset.values.length - 1)) * 100,
          );
          setControlValue(targetControl, controlValues.targetPercent);
          updateControlLabel("target", controlValues.targetPercent);
          state = initState();
          drawPlot();
          updateStats();
          renderCompare();
        };

        const updateAlgorithmControlState = () => {
          if (slopeControl instanceof HTMLInputElement) {
            slopeControl.disabled = controlValues.algorithm !== "sip";
          }
        };

        const onControlChange = () => {
          if (algorithmSelect) {
            controlValues.algorithm = algorithmSelect.value as Algorithm;
          }
          if (presetSelect) {
            controlValues.preset = presetSelect.value as Preset;
          }
          if (nControl instanceof HTMLInputElement) {
            controlValues.n = Number(nControl.value);
            updateControlLabel("n", controlValues.n);
          }
          if (noiseControl instanceof HTMLInputElement) {
            controlValues.noise = Number(noiseControl.value);
            updateControlLabel("noise", controlValues.noise);
          }
          if (dupControl instanceof HTMLInputElement) {
            controlValues.duplicateProbability = Number(dupControl.value);
            updateControlLabel("dup", controlValues.duplicateProbability);
          }
          if (dupLenControl instanceof HTMLInputElement) {
            controlValues.duplicateLength = Number(dupLenControl.value);
            updateControlLabel("dup-len", controlValues.duplicateLength);
          }
          if (targetControl instanceof HTMLInputElement) {
            controlValues.targetPercent = Number(targetControl.value);
            updateControlLabel("target", controlValues.targetPercent);
          }
          if (speedControl instanceof HTMLInputElement) {
            controlValues.speed = Number(speedControl.value);
            updateControlLabel("speed", controlValues.speed);
            if (playing) {
              stopPlayback();
              startPlayback();
            }
          }
          if (slopeControl instanceof HTMLInputElement) {
            controlValues.slopeInterval = Number(slopeControl.value);
            updateControlLabel("slope", controlValues.slopeInterval);
          }

          updateAlgorithmControlState();
          stopPlayback();
          const nextDatasetSettings = {
            n: controlValues.n,
            noise: controlValues.noise,
            duplicateProbability: controlValues.duplicateProbability,
            duplicateLength: controlValues.duplicateLength,
            preset: controlValues.preset,
          };
          const shouldRegenerate =
            nextDatasetSettings.n !== datasetSettings.n ||
            nextDatasetSettings.noise !== datasetSettings.noise ||
            nextDatasetSettings.duplicateProbability !==
              datasetSettings.duplicateProbability ||
            nextDatasetSettings.duplicateLength !==
              datasetSettings.duplicateLength ||
            nextDatasetSettings.preset !== datasetSettings.preset;
          datasetSettings = nextDatasetSettings;
          resetState(shouldRegenerate);
        };

        syncControls();
        updateAlgorithmControlState();
        resetState(true);

        if (algorithmSelect) algorithmSelect.addEventListener("change", onControlChange);
        if (presetSelect) presetSelect.addEventListener("change", onControlChange);
        if (nControl) nControl.addEventListener("input", onControlChange);
        if (noiseControl) noiseControl.addEventListener("input", onControlChange);
        if (dupControl) dupControl.addEventListener("input", onControlChange);
        if (dupLenControl) dupLenControl.addEventListener("input", onControlChange);
        if (targetControl) targetControl.addEventListener("input", onControlChange);
        if (speedControl) speedControl.addEventListener("input", onControlChange);
        if (slopeControl) slopeControl.addEventListener("input", onControlChange);

        if (stepButton) {
          stepButton.addEventListener("click", () => {
            stepState();
            drawPlot();
            updateStats();
            renderCompare();
          });
        }

        if (playButton) {
          playButton.addEventListener("click", () => {
            if (playing) stopPlayback();
            else startPlayback();
          });
        }

        if (resetButton) {
          resetButton.addEventListener("click", () => {
            stopPlayback();
            resetState();
          });
        }

        canvas.addEventListener("click", updateTargetFromPlot);

        resizeObserver = new ResizeObserver(() => {
          drawPlot();
        });
        resizeObserver.observe(canvas);

        const themeObserver = new MutationObserver(() => {
          drawPlot();
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["class"],
        });
      });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initSearchVisualizers);
  } else {
    initSearchVisualizers();
  }

  document.addEventListener("astro:page-load", initSearchVisualizers);
</script>
